// Base class for generated parser, for redepage v0.1.16

'use strict';

// TODO: instance method
// name → true, list of predicates which are tested for rule exit
// const ruleExitPredicates = {};

// list of predicates which are tested when continue parsing after error starts,
// i.e. there is a predicate on the first token to match after recover example
// `afterBrace` or just method which by default just sets this.conditionTokenIdx
 // and this.conditionStackLength and returns true?

class BaseParser {
  constructor( lexer, keywords, table ) {
    this.keywords = keywords;
    this.table = compileTable( table );
    this.lexer = lexer;
    this.tokens = undefined;
    this.eofIndex = undefined;
    this.tokenIdx = 0;
    this.recoverTokenIdx = -1;
    this.conditionTokenIdx = -1; // TODO: can we use recoverTokenIdx ?
    this.errorTokenIdx = -1;
    this.fixKeywordTokenIdx = -1;
    this.conditionStackLength = -1;
    this.nextTokenAsId = false;

    this.s = null;
    this.errorState = null;
    this.stack = [];            // [{ ruleState, followState, tokenIdx }]
    this.dynamic_ = {};
    this.prec_ = null;
    this.$hasErrors = null;
    // trace:
    this.trace = [];
  }

  init() {
    this.lexer.tokenize( this );
    this.eofIndex = this.tokens.length - 1;
    return this;
  }

  // methods for actions --------------------------------------------------------

  la() {                        // lookahead: complete token
    return this.tokens[this.tokenIdx];
  }
  lb() {                        // look back: complete token
    return this.tokens[this.tokenIdx - 1];
  }
  lr() {                        // return the first token matched by current rule
    return this.tokens[this.stack[this.stack.length - 1].tokenIdx];
  }

  // lookahead, error: ----------------------------------------------------------

  l() {                         // lookahead: token type
    return this.tokens[this.tokenIdx].type;
  }

  // instead of l() if keyword (reserved and/or unreserved) is in one of the cases
  lk() {                        // keyword lookahead
    const la = this.tokens[this.tokenIdx];
    if (!this.nextTokenAsId)
      return la.keyword || la.type;
    this.nextTokenAsId = false;
    return la.type;
  }

  e() {                         // error: report and recover
    const la = this.tokens[this.tokenIdx];
    if (this.trace.length > 1)
      this._trace( 'detected parsing error,', la );
    this.reportUnexpectedToken_( la );
    la.parsedAs = '';           // current token is erroneous

    if (this.errorTokenIdx === this.tokenIdx) {
      // TODO: investigate why this is not handled otherwise
      this.reportInternalError_( la );
      this.skipToken_();
      return false;
    }
    this.errorTokenIdx = this.tokenIdx;
    this.conditionStackLength = null;

    const { rewindDepth, syncSet } = this._calculateSyncSet();
    const recoverDepth = this._findSyncToken( syncSet, rewindDepth );
    this._recoverFromError( rewindDepth, recoverDepth );
    return false;
  }

  // instead of e() in default if lk() had been used and 'Id' is in a non-default case
  ei() {                // error (after trying to test again as identifier)
    if (!this.tokens[this.tokenIdx].keyword) // lk() had directly returned the type
      return this.e();
    this.nextTokenAsId = true;
    return false;               // do not execute action after it
  }

  // goto state: ----------------------------------------------------------------

  // go to end of the rule, in tracing parser: g(0)
  gr( follow ) {                // intersection follow set for fast exit
    if (this.stack[this.stack.length - 1].tokenIdx === this.tokenIdx)
      return this.e();  // match at least one token
    this.s = 0;
    // TODO: also have recursive flag in stack: was rule was called recursively?
    // extra val 'gr' when rule was called when it could reach the rule end
    const { type: lt, keyword: lk } = this.tokens[this.tokenIdx];
    if (lk &&            // Id also for unreserved, except after condition failure
        follow?.[0] === 'Id' && this.keywords[lk] !== false &&
        this.fixKeywordTokenIdx !== this.tokenIdx ||
        follow?.includes( lk || lt )) {
      this._tracePush( [ 'E', true ] );
      return true;
    }
    this._tracePush( [ 'E', 0 ] );
    // TODO: caching
    const { dynamic_ } = this;
    let match;
    let depth = this.stack.length;
    while (match == null && --depth) {
      this.dynamic_ = Object.getPrototypeOf( this.dynamic_ );
      const { followState } = this.stack[depth];
      match = this._pred_next( followState, lt, lk, 'E' );
      this._traceSubPush( match ?? 0 );
    }
    this.dynamic_ = dynamic_;
    // If the parser reaches this point with match = null, even the top-level rule
    // does not have a required token (typically `EOF`) at the end → the parser
    // must accept any token → rule exit possible (but no output '✔' in trace).
    return (match ?? true) || this.e();
  }

  // go to state; non-tracing parser: `this.s=‹state›` or `this.gr()`
  g( state, follow ) {
    if (!(state == null ? this.e() : state || this.gr( follow )))
      return false;
    this.s = state;             // is just `this.s=‹state›` in non-trace parser
    this._tracePush( this.s );
    return true;
  }

  // instead of gi() for `Id_all`
  giA( state, follow ) { // go to state (after trying to test again as identifier)
    if (!this.tokens[this.tokenIdx].keyword) // lk() had directly returned the type
      return this.g( state, follow );
    this.nextTokenAsId = true;
    return false;               // do not execute action after it
  }

  // instead of g() in default if lk() had been used and 'Id' is in a non-default case
  gi( state, follow ) { // go to state (after trying to test again as identifier)
    const lk = this.tokens[this.tokenIdx].keyword;
    // As opposed to ei(), we also check for reserved keywords here; this way, we
    // do not have to add reserved keywords from the follow-set to the `switch`.
    if (!lk || this.keywords[lk] === false) // TODO: consider fixKeywordTokenIdx ?
      return this.g( state, follow );
    this.nextTokenAsId = true;
    return false;               // do not execute action after it
  }

  // instead of gi() at rule end (RuleEnd_ in follow-set) for `Id_restricted`
  giR( state, follow ) { // go to state (after trying to test again as identifier)
    const lk = this.tokens[this.tokenIdx].keyword;
    if (!lk || this.keywords[lk] === false || this._keyword_after_rule( lk ))
      return this.g( state, follow );
    this.nextTokenAsId = true;
    return false;               // do not execute action after it
  }

  // instead of g() in a non-default case if there is a LL1 conflict
  gP( state, follow ) {                // goto state with standard weak-conflict prediction
    return this.lP( follow ) && this.g( state );
  }

  // match and consume token: ---------------------------------------------------

  m( state, token ) {           // match token = compare and consume
    return (this.tokens[this.tokenIdx].type === token)
      ? this.c( state )
      : this.e();
  }

  // instead of m() for identifiers via `Id` or `Id_restricted`
  mi( state, ident = true ) {   // match identifier token
    return (this.tokens[this.tokenIdx].type === 'Id')
      ? this.ci( state, ident )
      : this.e();
  }

  // instead of mi() for `Id_all`
  miA( state, ident = true ) {  // match identifier token
    return (this.tokens[this.tokenIdx].type === 'Id')
      ? this.ciA( state, ident )
      : this.e();
  }

  // instead of m() for reserved keywords or unreserved without conflict:
  mk( state, token ) {          // match keyword token
    return (this.tokens[this.tokenIdx].keyword === token)
      ? this.ck( state )
      : this.e();
  }

  c( state, parsedAs = 'token' ) { // consume token
    const la = this.tokens[this.tokenIdx];
    la.parsedAs = parsedAs;
    if (this.tokenIdx < this.eofIndex) ++this.tokenIdx;
    // TODO: handle identifier-including-reserved-words later (e.g. for id after a `.`)
    this.s = state;
    this.errorState = state;
    if (this.constructor.tracingParser)
      this._trace( `consume ${ tokenFullName( la, ' as ' ) },`, la );
    return true;
  }

  // instead of c() for identifiers, used both with l() and lk()
  ci( state, ident = 'ident' ) {   // consume identifier token
    const la = this.tokens[this.tokenIdx];
    if (this.keywords[la.keyword] === false)
      this.reportReservedWord_( la );
    // with error recovery: use that (consider this having a good score)
    return this.c( state, ident )
  }

  // instead of ci() for `Id_all`, used both with l() and lk()
  ciA( state, ident = 'ident' ) {  // consume identifier token, the "All" variant
    return this.c( state, ident )
  }

  // instead of c() for reserved or unreserved without conflict, requires lk()
  ck( state ) {                 // consume keyword token
    return this.c( state, 'keyword' )
  }

  // instead of ck() if there is a LL1 conflict
  ckP( state, first2 ) {      // consume unreserved keyword with weak conflict
    return this.lP( first2 ) && this.ck( state );
  }

  // for parser token or token set via `/`
  ckA( state ) {
    // if it really should be considered an Id, `set this.la().parsedAs` yourself
    return this.c( state, (this.l() === 'Id' ? 'keyword' : 'token') );
  }

  skipToken_() {
    ++this.tokenIdx;
  }

  // condition and precedence handling ------------------------------------------

  // state must match the goto-state of the default (there must be no default
  // action), or null for error, lP() must have been used before.  There is no
  // “or Id” behavior other than via gpP()

  // “go if user condition fails”
  gc( state, cond, arg ) {
    if (this.conditionTokenIdx === this.tokenIdx &&        // tested on same
        this.conditionStackLength == null) {               // after error recovery
      this._tracePush( [ 'C' ] );
      return true;
    }
    // TODO: let this[cond]( true ) return recovery badness in error case
    if (this.constructor.tracingParser) {
      const { traceName } = this[cond];
      this._tracePush( [ 'C', traceName?.call( this, arg ) ?? cond ] );
    }
    // calling the condition might have side effects (precendence conditions have)
    // → call tracing “name” before
    const fail = !this[cond]( true, arg );
    if (this.constructor.tracingParser)
      this._traceSubPush( !fail );
    // The default case must not have actions. If written in grammar with action,
    // the default must have <default=fallback>


    if (fail) {                 // TODO: extra gcK() method instead of check below
      // TODO: probably remove the following (and `conditionStackLength` tests)
      // altogether, error with gr() should be enough
      // if (this.conditionTokenIdx === this.tokenIdx &&
      //     this.conditionStackLength == this.stack.length)
      //   return this.e();        // already failed on same token in same rule
      // TODO: extra method necessary for academic case
      // ( 'unreserved' 'foo' | <cond> Id 'bar' )` with input `unreserved bar`
      const { keyword } = this.la();
      if (keyword && this.table[this.s][keyword])
        this.fixKeywordTokenIdx = this.tokenIdx;
      this.conditionTokenIdx = this.tokenIdx;
      this.conditionStackLength = this.stack.length;
    }
    return !fail || this.g( state ) && false;
  }

  ec( cond, arg ) {
    return this.gc( null, cond, arg );
  }

  // rule start, end and call: --------------------------------------------------

  rule_( state, followState = -1 ) { // start rule
    this.s = state;
    this._trace( [ 'call rule', state, ' at alt start' ], this.la() );
    this.stack.push( {
      ruleState: state,
      followState,
      tokenIdx: this.tokenIdx,
      prec: this.prec_,
    } );
    this.dynamic_ = Object.create( this.dynamic_ );
    this.prec_ = null;
    this.errorState ??= state;
  }

  exit_() {     // exit rule
    if (this.s)
      throw Error( `this.s === ${ this.s } // illegally set by action, or runtime/generator bug` );
    this.dynamic_ = Object.getPrototypeOf( this.dynamic_ );
    const caller = this.stack.pop();
    const immediately = this.tokenIdx === caller.tokenIdx;
    if (this.constructor.tracingParser) {
      const post = this.s == null &&
            (immediately
             ? ' immediately'
             : caller.followState == null
             ? ' unsuccessfully'
             : ' prematurely');
      const text = immediately ? '⚠ exit rule' : '⏎ exit rule';
      this.s = caller.followState; // for trace
      this._trace( [ text, caller.ruleState, post, this.stack.length + 1 ],
                   this.la() );
      if (this.tokenIdx === caller.tokenIdx &&
          this.stack.at(-1)?.followState != null)
        this.trace = [ this.errorState ]; // show last good state in trace
    }
    this.s = caller.followState;
    this.prec_ = caller.prec;
    if (this.s)
      this._skipErrorTokens();
    else if (this.s == null)
      return !immediately;      // attached actions are executed even with "unsuccessful exit"

    if (immediately)
      return false;
    this.errorState = this.s;
    return true;
  }

  // predicate used before rule call if with LL(1) conflict, 'Id' in other case
  lP( first2 ) {             // only start rule if this predicate returns true
    // nothing to check if not a non-reserved keyword:
    const { keyword: lk1 } = this.tokens[this.tokenIdx];
    if (!lk1 || !this.keywords[lk1])
      return true;

    const { type: lt2, keyword: lk2 } = this.tokens[this.tokenIdx + 1];
    // Argument first2 is just a performance hint with ckP():
    if (lk2 && first2?.[0] === 'Id' && this.keywords[lk2] !== false ||
        first2?.includes( lk2 || lt2 )) {
      this._tracePush( [ 'K', true ] );
      return true;
    }
    this._tracePush( [ 'K' ] );
    // now check it dynamically:
    let cmd = this.table[this.s][lk1];
    if (cmd[2] !== 1)
      throw Error( `Unexpected command '${ cmd?.[0] }' without prediction at state ${ this.s } for ‘${ lk1 }’` );

    // if not the keyword match, the command is “goto” or “rule call”
    const nextState = (cmd[0] === 'ck') ? cmd[1] : this._pred_keyword( cmd[1], lk1 );

    ++this.tokenIdx;            // for user lookahead fns and conditions
    const match = this._pred_next( nextState, lt2, lk2, 'K' );
    --this.tokenIdx;

    const r = match ?? true;
    if (match == null)
      this._traceSubPush( 0 );
    if (lt2 === 'IllegalToken')
      return true
    // TODO: instead of this IllegalToken test, implement a “confirm unreserved
    // keyword as Id” prediction which tests whether the token after the then-Id
    // matches.
    this._traceSubPush( r );
    if (!r)
      this.nextTokenAsId = true;
    return r;
  }

  // Now the helper methods =====================================================

  // Standard weak-conflict predicate -------------------------------------------

  _pred_keyword( state, keyword ) {
    // returns state after matching the first token as keyword, for lP()
    while (state) {
      this._traceSubPush( state );
      let cmd = this.table[state];
      if (!Array.isArray( cmd ))
        cmd = cmd[keyword] || cmd.Id || cmd[''];
      switch (cmd[0]) {
        case 'ck': case 'mk':
          return cmd[1];        // state after token consumption
        case 'g':               // TODO: another rule call?
          break;
        default:
          if (typeof cmd[0] !== 'number')
            throw Error( `Unexpected command ${ cmd[0] } at state ${ this.s }` );
      }
      state = cmd[1];
    }
    // reached end of rule without having consumed a token
    throw Error( 'Not supported: option for unreserved keywords in follow set' );
  }

  _pred_next( state, type, keyword, mode ) {
    let hasEnteredRule = false;
    while (state) {
      this._traceSubPush( state );
      let cmd = this.table[state];
      if (!Array.isArray( cmd )) {
        const lookahead = cmd[' lookahead'];
        cmd = lookahead
          ? cmd[this[lookahead]( mode )] || cmd['']
          : keyword && cmd[keyword] || cmd[type] || cmd[''];
      }
      switch (cmd[0]) {
        case 'c': case 'ck': case 'ciA': case 'ckA': // TODO: re-check ckA
          return true;
        case 'ci':
          if (!keyword ||
              this.keywords[keyword] !== false && this.fixKeywordTokenIdx !== this.tokenIdx)
            return true;
          cmd = this.table[state]['']; // is currently always 'g' or 'e'
          break;
        case 'm':
          return type === cmd[2];
        case 'mi':
          return type === 'Id' &&
            (!keyword ||
             this.keywords[keyword] !== false && this.fixKeywordTokenIdx !== this.tokenIdx);
        case 'miA':
          return type === 'Id';
        case 'mk':
          return keyword === cmd[2];
        case 'g': case 'e':
          break;
        default:
          if (typeof cmd[0] !== 'number')
            throw Error( `Unexpected command ${ cmd[0] } at state ${ this.s }` );
          // If the parser enters a rule, reaching the rule end (can happen with
          // option `minTokensMatched`) means "no match".
          hasEnteredRule = true;
          // If we want to support conditions before matching the first token in a
          // rule, we would have to handle `this.stack` and `this.dynamically_`.
      }
      // We could optimize with rule call - only 'Id' must be further investigated
      state = cmd[1];
    }
    // If invalid state, the second token does not match, e.g. for `VIRTUAL +`
    // or `VIRTUAL §` (with IllegalToken):
    if (state == null)
      return false;

    // Otherwise, the parser could end the rule after having matched the keyword
    // with prediction.  TODO: as we do not look behind the current rule for the
    // prediction, the tool can normally omit the prediction (and output a
    // message), no so with `ruleStartingWithUnreserved`.  We will rather look
    // behind the current rule _after_ having decided that the token is to be
    // matched as identifier.
    return !hasEnteredRule && null; // let caller decide how to interpret this
  }

  _keyword_after_rule( keyword ) {
    // TODO: this is a slow implementation - do dedicated traversal later
    // It is used in giR() only and this is currently used just once.
    // TODO: using mode = 'R' and tracing R(…)
    // TODO: investigate why this was not written before adding
    // `<default=fallback>` in rule `fromRefWithOptAlias`.
    return this._expecting()[keyword];
  }

  // Set of expected tokens: for error reporting and recovery -------------------

  // method like _exp_collect - conditions in called rules are evaluated with
  // unchanged stack and dynamic & no site-effects (are run with extra mode)

  // Calculate array of expected tokens
  _expecting( token ) {
    // Remark: rules must not have been exited too early, see _expecting call in re()
    const stack = this.stack.slice( 0, this.stack.length );
      // Immediately exit rules when no tokens have yet been consumed:
    let caller = stack.at( -1 );
    while (stack.length && this.tokenIdx === caller.tokenIdx) {
      --stack.length;
      caller = stack.at( -1 );
    }
    // Now calculate dictionary of expected tokens:
    const expecting = Object.create(null);
    let state = this.errorState;
    // At potential rule end, we must add follow sets of outer rules
    // TODO: we also need to unravel this.dynamic_ for translateParserToken_()
    while ((!state || this._exp_collect( expecting, this.table[state] )) && stack.length)
      state = stack.pop().followState;

    // Remove token (TODO later: instead, use conditions when collecting tokens):
    if (token) {
      const { keyword, type } = token;
      if (keyword && expecting[keyword] === true)
        delete expecting[keyword];
      else if (expecting[type] === true)
        delete expecting[type];
    }
    return expecting;
  }

  // TODO: use iterative alg, no recursive call, return state instead -----------
  // Add expected tokens to dictionary `expecting` starting at command `cmd`.
  // Return true if the rule end is reached, i.e. we also need to add the expected
  // tokens at the follow state of the current rule.  Argument `prop` is the token
  // name for `cmd` in a decision.

  // translateParserToken must work, i.e. this.stack and this.dynamic_ must be
  // according to stack level
  _exp_collect( expecting, cmd, prop, val = true ) {
    if (prop != null)
      cmd = cmd[prop];
    else if (!cmd)              // called on follow state of start rule
      return false;

    if (!Array.isArray( cmd )) {
      let reachedRuleEnd = false;
      for (const tok in cmd) {
        // TODO: except for `Id`, we can directly continue if `tok` is already in
        // `expecting`
        if (Object.hasOwn( cmd, tok ) && tok.charAt(0) !== ' ' &&
            this._exp_collect( expecting, cmd, tok, val ))
          reachedRuleEnd = true;
      }
      return reachedRuleEnd;
    }
    switch (cmd[0]) {
      case 'c': case 'ck':
        expecting[prop] ??= val;
        return false;
      case 'ckA':
        for (const tok of this.translateParserToken_( prop ))
          expecting[tok] ??= val;
        return false;
      case 'm': case 'mk':
        expecting[cmd[2]] ??= val;
        return false;
      case 'ci': case 'ciA': case 'mi': case 'miA':
        expecting['Id'] ??= val;
        // TODO: should we do s/th special, such that a reserved word is a sync
        // token for Id<all>?  Probably not, see also comment in _findSyncToken()
        return false;
      case 'g': case 'gi':
        if (!cmd[1])
          return cmd[1] === 0;
        //(this.stack[this.stack.length - 1].tokenIdx === this.tokenIdx);
        // TODO: add some assertion in generation that a decision has no two `g`s
        // to the same state (both in cases and default)
        // UPDATE: no, there will be at least gP()s
        // TOOD: do properly for (...)+ - currently, the token for directly
        // exiting the rule is also collected
        return this._exp_collect( expecting, this.table[cmd[1]], undefined, val );
      default:
        // a called rule must match at least one token → after having called a
        // rule, do not collect expecting tokens after exiting the rule
        if (typeof cmd[0] === 'number')
          this._exp_collect( expecting, this.table[cmd[1]], undefined, val );
        return false;
    }
  }

  translateParserToken_( token ) {
    return [ token ];
  }

  // Error recovery -------------------------------------------------------------

  _calculateSyncSet() {
    const { stack, dynamic_ } = this;
    let { length } = stack;
    while (stack[--length].tokenIdx === this.tokenIdx && length)
      this.dynamic_ = Object.getPrototypeOf( this.dynamic_ );
    this.stack = stack.slice( 0, ++length );

    // needs (copy of) "real stack"
    const syncSet = {};
    let depth = length + 1;
    if (!this._exp_collect( syncSet, this.table[this.errorState], undefined, depth ))
      --depth;
    while (this.stack.length) {
      this.dynamic_ = Object.getPrototypeOf( this.dynamic_ );
      const caller = this.stack.pop();
      // this.stack and this.dynamic_ must be changed for parser token
      // translation:
      if (caller.followState > 0 &&
          !this._exp_collect( syncSet, this.table[caller.followState], undefined, depth ))
        depth = this.stack.length;
    }
    syncSet.EOF ??= 0;
    this.stack = stack;
    this.dynamic_ = dynamic_;
    return { rewindDepth: length, syncSet };
  }

  _findSyncToken( syncSet, rewindDepth ) {
    this.recoverTokenIdx = this.tokenIdx;
    while (this.recoverTokenIdx <= this.eofIndex) {
      const { keyword, type } = this.tokens[this.recoverTokenIdx];
      const tryKeyw = keyword ? syncSet[keyword] : null;
      if (tryKeyw != null)
        return tryKeyw;
      const tryType = syncSet[type];
      // sync to Id only if in expected set of last good state or if after ';'
      if (tryType != null &&
          (type !== 'Id' || (!keyword || this.keywords[keyword] !== false) &&
           // reserved words do not match Id in expected-set, see _exp_collect()
           (tryType > rewindDepth || this.tokens[this.recoverTokenIdx - 1].type === ';')))
        return tryType;
      ++this.recoverTokenIdx;
    }
    throw Error( 'EOF must be last in `tokens`' );
  }

  _recoverFromError( rewindDepth, recoverDepth ) {
    this.s = null;
    let depth = this.stack.length;
    if (recoverDepth > depth) { // no rewind, no rule exit
      this.trace = [ this.errorState ]; // show last good state in trace
      this.s = this.errorState;
      if (this.s)
        this._skipErrorTokens();
    }
    else if (recoverDepth > rewindDepth) { // rewind, no rule exit
      this.stack[rewindDepth].followState = this.errorState;
    }
    while (depth > recoverDepth)
      this.stack[--depth].followState = null;
    // TODO: when the error is due to failed rule exit prediction, try to keep
    // existing followState (if that reaches RuleEnd_)
    // Continue parsing: ignore next predicate (TODO: except some specified ones?)
    this.conditionTokenIdx = this.tokenIdx;
    this.conditionStackLength = null;

    // TODO: re-check for rule calls which are at the optional rule end:
    //   x: 'x not'; b: 'b'? x {console.log('x→b')} 'b'?; a: b {console.log('b→a')} 'a'
    // with start rule `a` and input `x a`: output should be x→b + b→a
    // with start rule `a` and input `b a`: output should be b→a
    //
    // → the rule is: if a rule can continue at the specified state and has
    // matched at least one token, then its action is executed, otherwise not
  }

  _skipErrorTokens() {
    if (this.constructor.tracingParser && this.tokenIdx <= this.recoverTokenIdx) {
      this._trace( `skipped ${ this.recoverTokenIdx - this.tokenIdx } tokens to recover from error,`,
                   this.tokens[this.recoverTokenIdx] );
      }
    while (this.tokenIdx < this.recoverTokenIdx)
      this.skipToken_();
  }

  // small methods --------------------------------------------------------------

  log( ...args ) {
    console.log( ...args );
  }

  expectingForMessage_( token ) {
    return Object.keys( this._expecting( token ) ).map( tokenName ).sort().join( ',' );
  }

  reportError_( location, text ) {
    this.$hasErrors = true;
    this.log( `${ location }:`, text );
  }

  reportUnexpectedToken_( token ) {
    this.reportError_( token.location,
                       `Unexpected token ${ tokenFullName( token, ': ' ) } - expecting: ` +
                       this.expectingForMessage_( token ) );
  }

  reportInternalError_( token ) {
    this.reportError_( token.location,
                       `Unexpected token at ${ tokenFullName( token, ': ' ) } - skipped one token` );
  }

  reportReservedWord_( token ) {
    this.reportError_( token.location,
                       `Unexpected reserved word ‘${ token.text }’ - expecting: ` +
                       this.expectingForMessage_() );
  }

  errorAndRecoverOutside( token, text ) { // TODO: re-check
    // TODO: TMP
    this.reportError_( token.location, text );
    while (this.l() !== ';')
      this.skipToken_();
    this.s = null;
    return false;
  }

  _tracePush( state ) {
    if (this.constructor.tracingParser)
      this.trace.push( state ?? '⚠' );
  }
  _traceSubPush( state ) {
    if (this.constructor.tracingParser)
      this.trace.at(-1).push( state );
  }
  traceAction( location ) {     // TODO: remove
    this._trace( location );
  }

  _trace( msg, la ) {
    if (!this.constructor.tracingParser)
      return;
    // indentation according to rule call depth is nice, but only if without
    // excessive spaces → truncate:
    const indent = '  '.repeat( this.stack.length % 32 );
    if (!la) {
      let line = '         execute action'; // align with non-action messages
      if (this.trace.length > 1) { // i.e. with some 'g' command
        line += ', states: ' + this.trace.map( traceStep ).join( ' → ' );
        this.trace = [ this.s ?? '⚠' ];
      }
      this.log( indent, line, `(${ msg })` );
      return;
    }
    const { location } = la;
    if (!this.trace.length) {
      this.log( `In ${ location.file }:` );
      this.trace = [ -1 ];
    }
    this.trace.push( this.s ?? '⚠' );
    if (Array.isArray( msg )) {
      const [ intro, state, finale, exitLength ] = msg;
      let depth = (exitLength) ? exitLength - 1 : this.stack.length + 1;
      let length = this.trace.length - 1;
      this.trace[length] = `${ this.trace[length] }(${ depth })`;
      depth = exitLength || this.stack.length;
      while (length && typeof this.trace[--length] !== 'number')
        ;
      this.trace[length] = `${ this.trace[length] }(${ depth })`;

      let start = state;
      while (typeof this.table[--start] !== 'string')
        ;
      const post = (exitLength || start + 1 < state) && finale;
      msg = `${ intro } “${ this.table[start] }”${ post || '' },`;
    }
    // Yes, I know util.format, but do not want to have a `require` in this file
    const line = location.line < 1e5 ? `    ${ location.line }`.slice(-5) : `${ location.line }`;
    const col = location.col < 1e4 ? `:${ location.col }   `.slice(0,5) : `:${location.col }`;
    this.log( line + col + indent + msg,
              'states:', this.trace.map( traceStep ).join( ' → ' ) );
    this.trace = [ this.s ?? '⚠' ];
  }

  inSameRule_( lowState, highState ) {
    if (lowState > highState)
      [ lowState, highState ] = [ highState, lowState ];
    while (lowState < highState) {
      if (typeof this.table[++lowState] === 'string') // rule boundary
        return false;
    }
    return true;
  }

  // Predefined conditions with extra option names:

  precLeft_( _test, prec ) {    // <prec=…>, <…,assoc=left>, <…,prefix=once>
    const parentPrec = this.stack.at( -1 ).prec;
    if (parentPrec != null && parentPrec >= prec)
      return false;
    this.prec_ = prec;
    return true;
  }
  precRight_( _test, prec ) {   // <…,assoc=right>, <…,prefix>
    const parentPrec = this.stack.at( -1 ).prec;
    if (parentPrec != null && parentPrec >= prec)
      return false;
    this.prec_ = prec - 1;
    return true;
  }
  precNone_( _test, prec ) {    // <…,assoc=none>, <…,postfix=once>
    const parentPrec = this.stack.at( -1 ).prec;
    if (parentPrec != null && parentPrec >= prec ||
        this.prec_ != null && this.prec_ <= prec)
      return false;
    this.prec_ = prec;
    return true;
  }
  precPost_( _test, prec ) {    // <…,postfix>
    const parentPrec = this.stack.at( -1 ).prec;
    if (parentPrec != null && parentPrec >= prec ||
        this.prec_ != null && this.prec_ < prec)
      return false;
    this.prec_ = prec;
    return true;
  }
}
const members = BaseParser.prototype;
// functions below are to be called with `call` to set `this`

members.precLeft_.traceName = function( prec ) {
  const parentPrec = this.stack.at( -1 ).prec;
  return `${ parentPrec ?? '-∞' }<${ prec }`;
}
members.precRight_.traceName = function( prec ) {
  const left = this.precLeft_.traceName.call( this, prec );
  return `${ left },↓`;
}
members.precNone_.traceName = function( prec ) {
  const left = this.precLeft_.traceName.call( this, prec );
  return `${ left }<${ this.prec_ == null ? '∞' : this.prec_ }`;
}
members.precPost_.traceName = function( prec ) {
  const left = this.precLeft_.traceName.call( this, prec );
  return `${ left }≤${ this.prec_ == null ? '∞' : this.prec_ }`;
}

function traceStep( step ) {
  if (!Array.isArray( step ))
    return step;
  const result = { true: '✔', false: '✖' }[step.at( -1 )] ?? '';
  const intro = (typeof step[1] === 'number') ? '→' : '';
  const arg = step.slice( 1, result ? -1 : undefined ).join( '→' );
  return `${ step[0] }(${ intro }${ arg })${ result }`;
}

function tokenName( type ) {
  if (typeof type !== 'string')
    type = (!type.parsedAs || type.parsedAs === 'keyword') && type.keyword || type.type;
  return (/^[A-Z]+/.test( type )) ? `‹${ type }›` : `‘${ type }’`;
}

function tokenFullName( token, sep ) {
  return (token.parsedAs && token.parsedAs !== 'keyword' && token.parsedAs !== 'token' ||
          token.type !== 'Id' && token.type !== token.text && token.text)
    ? `‘${ token.text }’${ sep }${ tokenName( token ) }`
    : tokenName( token );
}

function compileTable( table ) {
  if (table.$compiled)
    return table;
  for (const line of table) {
    if (typeof line !== 'object' || Array.isArray( line ))
      continue;
    const cache = Object.create( null ); // very sparse array
    for (const prop of Object.keys( line )) {
      const alt = line[prop];
      if (!Array.isArray( alt ) && prop.charAt(0) !== ' ') // string or number
        line[prop] = (typeof alt === 'string') ? line[alt] : (cache[alt] ??= [ 'g', alt ]);
    }
    if (!line[''])
      line[''] = [ 'e' ];
  }
  table.$compiled = true;
  return table;
}

module.exports = BaseParser;
